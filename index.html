<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PopCraft ‚Äî Viewer (fix transparence & upright)</title>
  <style>
    :root{ --bg:#0e0f12; --accent:#06c9d8; }
    *{ box-sizing:border-box; }
    html,body{ margin:0; height:100%; background:#111; color:#e9eef1; font-family:system-ui, -apple-system, "Segoe UI", Roboto, Inter, Arial; }
    header{ height:100px; display:grid; place-items:center; background:linear-gradient(135deg, var(--accent) 50%, transparent 50%); }
    header img{ height:80px; object-fit:contain; }
    main{ display:flex; height:calc(100vh - 100px); gap:0; }
    #viewer{ flex:1 1 0; background:#0b0c0e; min-width:320px; }
    #sidebar{ width:340px; background:#141619; padding:14px; box-shadow:-6px 0 24px rgba(0,0,0,0.6); }
    #status{ margin-bottom:12px; padding:8px 10px; border-radius:6px; background:rgba(0,0,0,.6); color:#aefaa0; font:13px/1.3 monospace }
    label, button{ display:inline-block; margin:6px 4px 6px 0; cursor:pointer; padding:8px 10px; border-radius:8px; background:#06c9d8; color:#041414; border:none; font-weight:700 }
    #username{ width:100%; padding:8px; margin:8px 0; border-radius:8px; border:none; }
    .hint{ color:#9aa4ab; font-size:13px; margin-top:10px; background:rgba(0,0,0,0.14); padding:8px; border-radius:8px }
    ul{ padding-left:16px; color:#c9d3d8; }
    .small{ font-size:13px; color:#b9c2c7 }
  </style>

  <!-- es-module-shims pour compatibilit√© importmap -->
  <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <header>
    <img src="popcraft_title.png" alt="PopCraft" onerror="this.style.display='none'">
  </header>

  <main>
    <div id="viewer"></div>

    <aside id="sidebar">
      <div id="status">‚è≥ Chargement‚Ä¶</div>

      <div>
        <label for="fileInput">üìÇ Uploader skin</label>
        <input id="fileInput" type="file" accept="image/png" style="display:none">
        <label id="fileLabel" style="background:#333;color:#fff;">Aucun</label>
      </div>

      <div style="margin-top:10px">
        <input id="username" placeholder="Pseudo Minecraft" />
        <button id="fetchSkin">üîç Chercher</button>
      </div>

      <div style="margin-top:12px">
        <button id="resetCam">‚ü≤ Reset vue</button>
        <button id="applyDetectedOverlay" title="Re-apply heuristic overlay">üîß Re-d√©tecter overlay</button>
      </div>

      <div class="hint" style="margin-top:14px">
        Si la transparence masque la couche inf√©rieure, clique sur <strong>Re-d√©tecter overlay</strong> pour forcer la d√©tection.
      </div>

      <div style="margin-top:12px">
        <div class="small">Meshes d√©tect√©s (fig_)</div>
        <div id="meshListBox" style="max-height:220px; overflow:auto; margin-top:6px; background:rgba(255,255,255,0.02); padding:8px; border-radius:6px"></div>
      </div>
      <div style="margin-top:10px">
        <div class="small">Notes :</div>
        <ul>
          <li>Prefixe <code>box_</code> ‚Üí bo√Æte</li>
          <li>Prefixe <code>fig_</code> ‚Üí figurine</li>
          <li>Si overlay (chapeau) masque la base : coche le mesh correspondant comme ¬´ overlay ¬ª ci-dessous.</li>
        </ul>
      </div>
    </aside>
  </main>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const viewer = document.getElementById('viewer');
    const statusEl = document.getElementById('status');
    const fileInput = document.getElementById('fileInput');
    const fileLabel = document.getElementById('fileLabel');
    const usernameEl = document.getElementById('username');
    const fetchSkinBtn = document.getElementById('fetchSkin');
    const meshListBox = document.getElementById('meshListBox');
    const applyDetectedOverlayBtn = document.getElementById('applyDetectedOverlay');
    const resetCamBtn = document.getElementById('resetCam');

    // three basics
    const W = Math.max(320, viewer.clientWidth);
    const H = Math.max(240, viewer.clientHeight);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, W/H, 0.1, 1000);
    camera.position.set(0, 2, 6);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(W, H);
    viewer.appendChild(renderer.domElement);

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, .85));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(4,6,6);
    scene.add(dir);

    // controls (camera orbit) ‚Äî autoRotate integrated
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.enableZoom = false; // disable zoom
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.4;
    controls.minPolarAngle = 0.35;
    controls.maxPolarAngle = Math.PI - 0.35;

    // fallback cube (visible until model loads)
    const cube = new THREE.Mesh(
      new THREE.BoxGeometry(2,2,2),
      new THREE.MeshStandardMaterial({ color: 0x00ff00 })
    );
    scene.add(cube);
    statusEl.textContent = '‚úÖ Cube affich√© (en attente de pop.glb)‚Ä¶';

    // modelGroup rotates around center
    const modelGroup = new THREE.Group();
    scene.add(modelGroup);

    const loader = new GLTFLoader();
    const url = 'pop.glb' + (location.hostname.includes('github.io') ? `?v=${Date.now()}` : '');

    // store fig meshes info: {name, mesh, overlay:boolean}
    const figurine = []; // array of {name, mesh, overlay}

    // Heuristic overlay name test
    function isLikelyOverlayName(name){
      if(!name) return false;
      const n = name.toLowerCase();
      return (n.includes('overlay') || n.includes('hat') || n.includes('layer') || n.includes('cap') || n.includes('top') || n.match(/_1$|_02$|layer2|outer/));
    }

    // function to build UI list of fig_ meshes and allow toggling overlay
    function buildMeshListUI(){
      meshListBox.innerHTML = '';
      if(figurine.length === 0){ meshListBox.innerHTML = '<div class="small">Aucun mesh fig_ d√©tect√©</div>'; return; }
      figurine.forEach((f, i)=>{
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
        const left = document.createElement('div'); left.textContent = f.name; left.style.fontSize='13px';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = !!f.overlay;
        cb.addEventListener('change', ()=>{
          f.overlay = cb.checked;
          applySkinAndLayers(currentSkinTexture); // reapply with new overlay flags
        });
        row.appendChild(left);
        const wrap = document.createElement('div'); wrap.appendChild(cb);
        row.appendChild(wrap);
        meshListBox.appendChild(row);
      });
    }

    let currentSkinTexture = null; // keep loaded texture

    // load glb
    loader.load(url, (gltf)=>{
      console.log('GLTF loaded', gltf);
      statusEl.textContent = '‚úÖ pop.glb charg√© ‚Äî pr√©paration‚Ä¶';
      scene.remove(cube);

      const model = gltf.scene;
      modelGroup.add(model);

      // compute scale & center
      const bbox = new THREE.Box3().setFromObject(model);
      const size = new THREE.Vector3(); bbox.getSize(size);
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      const desired = 3.2;
      const scl = desired / maxDim;
      model.scale.setScalar(scl);

      // recalc center and shift model so modelGroup is centered
      const bbox2 = new THREE.Box3().setFromObject(model);
      const center = new THREE.Vector3(); bbox2.getCenter(center);
      model.position.sub(center);

      // traverse and collect fig_ meshes and apply box_ textures immediately
      const texLoader = new THREE.TextureLoader();
      let boxTextureLoaded = false;

      texLoader.load('box_template_blank.png', (boxTex)=>{
        boxTex.flipY = false;
        boxTex.encoding = THREE.sRGBEncoding;
        boxTex.magFilter = THREE.NearestFilter;
        boxTex.minFilter = THREE.NearestFilter;
        boxTex.generateMipmaps = false;

        model.traverse((child)=>{
          if(child.isMesh && child.name && child.name.startsWith('box_')){
            child.material = new THREE.MeshStandardMaterial({ map: boxTex });
          }
        });
        boxTextureLoaded = true;
        console.log('Box texture applied');
      }, undefined, ()=>{ console.warn('box_template_blank.png not found'); });

      figurine.length = 0;
      let idx = 0;
      model.traverse((child)=>{
        if(child.isMesh && child.name && child.name.startsWith('fig_')){
          const name = child.name.trim() || `fig_${idx++}`;
          figurine.push({ name, mesh: child, overlay: isLikelyOverlayName(name) });
        }
      });

      buildMeshListUI();

      // Try default skin.png
      texLoader.load('skin.png', (skinTex) => {
        currentSkinTexture = skinTex;
        applySkinAndLayers(skinTex);
        statusEl.textContent = '‚úÖ Mod√®le et skin par d√©faut appliqu√©s';
      }, undefined, ()=>{
        statusEl.textContent = '‚ö†Ô∏è Mod√®le charg√© ‚Äî skin par d√©faut absent';
      });

      // controls interaction: disable autoRotate on user interaction, re-enable after
      controls.addEventListener('start', ()=>{
        controls.autoRotate = false;
      });
      controls.addEventListener('end', ()=>{
        // if camera is under model too much, animate back to upright camera
        setTimeout(()=> {
          // compute spherical coords from target (controls.target defaults to origin)
          const offset = camera.position.clone().sub(controls.target);
          const sph = new THREE.Spherical(); sph.setFromVector3(offset);
          const desiredPhi = Math.PI / 2; // horizontal
          // if user looked too much under or over, animate to desiredPhi
          if(Math.abs(sph.phi - desiredPhi) > 0.5){
            animateCameraToPhi(desiredPhi, 500);
          }
          // re-enable autoRotate gently
          setTimeout(()=> controls.autoRotate = true, 800);
        }, 300);
      });

    }, (ev)=>{
      if(ev.total) statusEl.textContent = `‚¨áÔ∏è Chargement pop.glb ${(ev.loaded/ev.total*100).toFixed(0)}%`;
    }, (err)=>{
      console.error('Erreur glTF:', err);
      statusEl.style.color = '#ff9b9b';
      statusEl.textContent = '‚ùå Erreur: pop.glb manquant (placez-le √† la racine)';
      (function loop(){ requestAnimationFrame(loop); cube.rotation.y += 0.01; controls.update(); renderer.render(scene, camera); })();
    });

    // apply skin + layer handling
    function applySkinAndLayers(texture){
      if(!texture) return;
      texture.flipY = false;
      texture.encoding = THREE.sRGBEncoding;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.generateMipmaps = false;

      // apply base and overlay using overlay flag
      figurine.forEach(item=>{
        const mesh = item.mesh;
        // clone geometry materials to avoid side effects
        if(item.overlay){
          // overlay material: render after base, don't write depth so base shows through
          const mat = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: true,
            alphaTest: 0.05,
            depthWrite: false,
            side: THREE.DoubleSide
          });
          mesh.material = mat;
          mesh.renderOrder = 2000;
        } else {
          const mat = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: false,
            alphaTest: 0.01,
            depthWrite: true,
            side: THREE.FrontSide
          });
          mesh.material = mat;
          mesh.renderOrder = 10;
        }
      });
      currentSkinTexture = texture;
      console.log('Skin & layers applied (overlay flags respected)');
    }

    // animate camera phi to targetPhi (ms)
    let camAnimRunning = false;
    function animateCameraToPhi(targetPhi, duration = 500){
      if(camAnimRunning) return;
      camAnimRunning = true;
      controls.enabled = false;
      const start = performance.now();
      const offset = camera.position.clone().sub(controls.target);
      const sph = new THREE.Spherical(); sph.setFromVector3(offset);
      const startPhi = sph.phi;
      const startTheta = sph.theta;
      const radius = sph.radius;
      const targetTheta = startTheta; // keep same heading

      function step(t){
        const now = performance.now();
        const p = Math.min(1, (now - start)/duration);
        const ease = (p<0.5) ? (2*p*p) : (-1 + (4-2*p)*p); // simple ease
        const phi = THREE.MathUtils.lerp(startPhi, targetPhi, ease);
        const newS = new THREE.Spherical(radius, phi, targetTheta);
        const newPos = new THREE.Vector3().setFromSpherical(newS).add(controls.target);
        camera.position.copy(newPos);
        camera.lookAt(controls.target);
        if(p < 1){
          requestAnimationFrame(step);
        } else {
          controls.enabled = true;
          camAnimRunning = false;
        }
      }
      requestAnimationFrame(step);
    }

    // UI: file upload handling
    fileInput.addEventListener('change', (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      fileLabel.textContent = f.name;
      const url = URL.createObjectURL(f);
      const texLoader = new THREE.TextureLoader();
      texLoader.load(url, (tex)=>{
        applySkinAndLayers(tex);
        statusEl.textContent = '‚úÖ Skin upload appliqu√©';
      }, undefined, (err)=> { console.error(err); statusEl.textContent = '‚ùå Erreur skin upload'; });
    });

    // label clickable to open file dialog
    fileLabel.addEventListener('click', ()=> fileInput.click());
    document.querySelector('label[for="fileInput"]').addEventListener('click', ()=> fileInput.click());

    // fetch skin via Mojang -> crafatar
    fetchSkinBtn.addEventListener('click', async ()=>{
      const name = usernameEl.value.trim();
      if(!name) { statusEl.textContent = '‚ö†Ô∏è Entre un pseudo'; return; }
      statusEl.textContent = `üîé Recherche ${name}‚Ä¶`;
      try{
        // Query Mojang for UUID
        const res = await fetch('https://api.mojang.com/users/profiles/minecraft/' + encodeURIComponent(name));
        if(!res.ok) throw new Error('user not found');
        const j = await res.json();
        const uuid = j.id;
        const skinUrl = 'https://crafatar.com/skins/' + uuid;
        const texLoader = new THREE.TextureLoader();
        texLoader.load(skinUrl, (tex)=>{
          applySkinAndLayers(tex);
          statusEl.textContent = `‚úÖ Skin de ${name} appliqu√©`;
        }, undefined, ()=> { statusEl.textContent = '‚ùå Erreur chargement skin'; });
      }catch(e){
        console.warn(e);
        statusEl.textContent = `‚ùå Pseudo introuvable`;
      }
    });

    // button: re-detect overlay heuristics and reapply
    applyDetectedOverlayBtn.addEventListener('click', ()=>{
      figurine.forEach(item => { item.overlay = isLikelyOverlayName(item.name); });
      buildMeshListUI();
      if(currentSkinTexture) applySkinAndLayers(currentSkinTexture);
      statusEl.textContent = 'üîß Overlay heuristique r√©appliqu√©e';
    });

    // reset camera: go to default position smoothly
    resetCamBtn.addEventListener('click', ()=> animateCameraToPhi(Math.PI/2, 400));

    // initial render loop
    function renderLoop(){
      requestAnimationFrame(renderLoop);
      controls.update();
      // gentle upright of modelGroup rotation X/Z (if any) towards 0
      modelGroup.rotation.x = THREE.MathUtils.lerp(modelGroup.rotation.x, 0, 0.08);
      modelGroup.rotation.z = THREE.MathUtils.lerp(modelGroup.rotation.z, 0, 0.08);
      renderer.render(scene, camera);
    }
    renderLoop();

    // resize handling
    window.addEventListener('resize', ()=>{
      const w = Math.max(320, viewer.clientWidth), h = Math.max(240, viewer.clientHeight);
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    });

  </script>
</body>
</html>
