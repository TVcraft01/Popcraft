<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>PopCraft — Aperçu</title>
  <style>
    body {
      margin: 0;
      background: #000;
      color: #fff;
      overflow: hidden;
    }
    header {
      position: relative;
      text-align: center;
      padding: 20px 0;
      background: linear-gradient(160deg, #06c9d8 50%, transparent 50%);
    }
    header img {
      height: 100px;
    }
    #viewer {
      width: 100vw;
      height: calc(100vh - 140px);
    }
  </style>
</head>
<body>
  <header>
    <img src="popcraft_title.png" alt="PopCraft">
  </header>
  <div id="viewer"></div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/OBJLoader.js"></script>

  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / (window.innerHeight-140), 0.1, 1000);
    camera.position.z = 5;

    let renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight-140);
    document.getElementById("viewer").appendChild(renderer.domElement);

    // Lumières
    let light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,5,5).normalize();
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040));

    let object;
    let loader = new THREE.OBJLoader();
    let texLoader = new THREE.TextureLoader();
    let texture = texLoader.load("box_template_blank.png");

    loader.load("pop.obj", (obj)=>{
      obj.traverse((child)=>{
        if(child.isMesh){
          child.material = new THREE.MeshStandardMaterial({map: texture});
        }
      });
      object = obj;
      scene.add(object);
    }, undefined, (err)=>{
      console.error("Erreur chargement OBJ:", err);
      // Fallback : cube gris
      let geom = new THREE.BoxGeometry(1,1,1);
      let mat = new THREE.MeshStandardMaterial({color:0x888888});
      object = new THREE.Mesh(geom, mat);
      scene.add(object);
    });

    // Contrôles rotation
    let isDragging = false, prevX=0, prevY=0;
    renderer.domElement.addEventListener("mousedown", (e)=>{isDragging=true; prevX=e.clientX; prevY=e.clientY;});
    renderer.domElement.addEventListener("mouseup", ()=>{isDragging=false;});
    renderer.domElement.addEventListener("mousemove", (e)=>{
      if(isDragging && object){
        let dx = e.clientX - prevX;
        let dy = e.clientY - prevY;
        object.rotation.y += dx*0.01;
        object.rotation.x += dy*0.01;
        prevX = e.clientX;
        prevY = e.clientY;
      }
    });
    // Tactile
    renderer.domElement.addEventListener("touchstart",(e)=>{isDragging=true; prevX=e.touches[0].clientX; prevY=e.touches[0].clientY;});
    renderer.domElement.addEventListener("touchend",()=>{isDragging=false;});
    renderer.domElement.addEventListener("touchmove",(e)=>{
      if(isDragging && object){
        let dx = e.touches[0].clientX - prevX;
        let dy = e.touches[0].clientY - prevY;
        object.rotation.y += dx*0.01;
        object.rotation.x += dy*0.01;
        prevX = e.touches[0].clientX;
        prevY = e.touches[0].clientY;
      }
    });

    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener("resize", ()=>{
      camera.aspect = window.innerWidth/(window.innerHeight-140);
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight-140);
    });
  </script>
</body>
</html>
