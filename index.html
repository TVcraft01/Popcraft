<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PopCraft ‚Äî Viewer (multi mod√®les, skin + overlay)</title>
  <style>
    :root{ --bg:#0e0f12; --accent:#06c9d8; }
    *{ box-sizing:border-box; }
    html,body{ margin:0; height:100%; background:#111; color:#e9eef1; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; }
    header{ height:100px; display:grid; place-items:center; background:linear-gradient(135deg,var(--accent) 50%,transparent 50%); }
    header img{ height:80px; object-fit:contain; }
    main{ display:flex; height:calc(100vh - 100px); }
    #viewer{ flex:1 1 0; background:#0b0c0e; min-width:320px; display:flex; align-items:center; justify-content:flex-start; }
    #sidebar{ width:360px; background:#141619; padding:14px; box-shadow:-6px 0 24px rgba(0,0,0,0.6); }
    #status{ margin-bottom:12px; padding:8px 10px; border-radius:6px; background:rgba(0,0,0,.6); color:#aefaa0; font:13px/1.3 monospace }
    label, button, select{ display:inline-block; margin:6px 4px 6px 0; cursor:pointer; padding:8px 10px; border-radius:8px; background:#06c9d8; color:#041414; border:none; font-weight:700 }
    select{ background:#222; color:#fff; }
    #username{ width:100%; padding:8px; margin:8px 0; border-radius:8px; border:none; }
    .hint{ color:#9aa4ab; font-size:13px; margin-top:10px; background:rgba(0,0,0,0.14); padding:8px; border-radius:8px }
    ul{ padding-left:16px; color:#c9d3d8; }
    .small{ font-size:13px; color:#b9c2c7 }
    #meshListBox{ max-height:220px; overflow:auto; margin-top:6px; background:rgba(255,255,255,0.02); padding:8px; border-radius:6px }
  </style>

  <script async src="https://cdn.jsdelivr.net/npm/es-module-shims@1.10.0/dist/es-module-shims.min.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <header>
    <img src="popcraft_title.png" alt="PopCraft" onerror="this.style.display='none'">
  </header>

  <main>
    <div id="viewer"></div>

    <aside id="sidebar">
      <div id="status">‚è≥ Chargement‚Ä¶</div>

      <div id="modelSelectorBox" style="display:none; margin-bottom:8px">
        <div class="small">Choisir un mod√®le :</div>
        <select id="modelSelect"></select>
        <button id="reloadModel">‚Üª Charger</button>
      </div>

      <div>
        <label for="fileInput">üìÇ Uploader skin</label>
        <input id="fileInput" type="file" accept="image/png" style="display:none">
        <label id="fileLabel" style="background:#333;color:#fff;">Aucun</label>
      </div>

      <div style="margin-top:10px">
        <input id="username" placeholder="Pseudo Minecraft" />
        <button id="fetchSkin">üîç Chercher</button>
      </div>

      <div style="margin-top:12px">
        <button id="resetCam">‚ü≤ Reset vue</button>
        <button id="applyDetectedOverlay" title="Re-apply heuristic overlay">üîß Re-d√©tecter overlay</button>
      </div>

      <div class="hint" style="margin-top:14px">
        Si la transparence masque la couche inf√©rieure, coche/d√©coche l'overlay correspondant ci-dessous ou clique sur <strong>Re-d√©tecter overlay</strong>.
      </div>

      <div style="margin-top:12px">
        <div class="small">Meshes d√©tect√©s (fig_)</div>
        <div id="meshListBox"></div>
      </div>
    </aside>
  </main>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /*********************
     * Elements & state
     *********************/
    const viewer = document.getElementById('viewer');
    const statusEl = document.getElementById('status');
    const modelSelectorBox = document.getElementById('modelSelectorBox');
    const modelSelect = document.getElementById('modelSelect');
    const reloadModelBtn = document.getElementById('reloadModel');

    const fileInput = document.getElementById('fileInput');
    const fileLabel = document.getElementById('fileLabel');
    const usernameEl = document.getElementById('username');
    const fetchSkinBtn = document.getElementById('fetchSkin');
    const applyDetectedOverlayBtn = document.getElementById('applyDetectedOverlay');
    const resetCamBtn = document.getElementById('resetCam');
    const meshListBox = document.getElementById('meshListBox');

    // three basics
    let W = Math.max(320, viewer.clientWidth);
    let H = Math.max(240, viewer.clientHeight);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, W/H, 0.1, 1000);
    camera.position.set(0, 2, 6);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(W, H);
    viewer.appendChild(renderer.domElement);

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, .85));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(4,6,6);
    scene.add(dir);

    // controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.4;
    controls.minPolarAngle = 0.35;
    controls.maxPolarAngle = Math.PI - 0.35;

    // model group (for centered rotation)
    let modelGroup = new THREE.Group();
    scene.add(modelGroup);

    const loader = new GLTFLoader();

    // figurine meshes metadata
    const figurine = []; // { name, mesh, overlay:boolean }
    let currentSkinTexture = null;

    /*********************
     * Helpers
     *********************/
    function setStatus(txt, color){
      statusEl.textContent = txt;
      if(color) statusEl.style.color = color; else statusEl.style.color = '';
    }

    function disposeObject(obj){
      obj.traverse((c)=>{
        if(c.isMesh){
          if(c.geometry){ c.geometry.dispose?.(); }
          if(c.material){
            if(Array.isArray(c.material)){
              c.material.forEach(m=>{ m.map?.dispose?.(); m.dispose?.(); });
            } else {
              c.material.map?.dispose?.();
              c.material.dispose?.();
            }
          }
        }
      });
    }

    // apply skin & overlay flags
    function applySkinAndLayers(texture){
      if(!texture) return;
      texture.flipY = false;
      texture.encoding = THREE.sRGBEncoding;
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;
      texture.generateMipmaps = false;

      figurine.forEach(item=>{
        const mesh = item.mesh;
        if(!mesh) return;
        if(item.overlay){
          const mat = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: true,
            alphaTest: 0.05,
            depthWrite: false,
            side: THREE.DoubleSide
          });
          mesh.material = mat;
          mesh.renderOrder = 2000;
        } else {
          const mat = new THREE.MeshStandardMaterial({
            map: texture,
            transparent: false,
            alphaTest: 0.01,
            depthWrite: true,
            side: THREE.FrontSide
          });
          mesh.material = mat;
          mesh.renderOrder = 10;
        }
      });
      currentSkinTexture = texture;
      console.log('Skin appliqu√© ‚Äî overlay flags respect√©es');
    }

    // overlay detection
    function detectOverlayFromName(name){
      if(!name) return false;
      if(name.startsWith('fig_2nd_layer_')) return true;
      const n = name.toLowerCase();
      return n.includes('2nd') || n.includes('overlay') || n.includes('layer') || n.includes('hat') || n.includes('_1') || n.includes('outer');
    }

    function buildMeshListUI(){
      meshListBox.innerHTML = '';
      if(figurine.length === 0){
        meshListBox.innerHTML = '<div class="small">Aucun mesh fig_ d√©tect√©</div>';
        return;
      }
      figurine.forEach((f, i)=>{
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
        const left = document.createElement('div'); left.textContent = f.name; left.style.fontSize='13px';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = !!f.overlay;
        cb.addEventListener('change', ()=>{
          f.overlay = cb.checked;
          applySkinAndLayers(currentSkinTexture);
        });
        row.appendChild(left);
        const wrap = document.createElement('div'); wrap.appendChild(cb);
        row.appendChild(wrap);
        meshListBox.appendChild(row);
      });
    }

    /*********************
     * Model list handling
     *********************/
    async function loadModelIndex(){
      try{
        const res = await fetch('3D_display/index.json');
        if(!res.ok) throw new Error('3D_display/index.json introuvable');
        const data = await res.json();

        let list = [];
        if(Array.isArray(data)){
          if(typeof data[0] === 'string'){
            list = data.map(id => ({ id, file: `${id}.glb`, displayName: id }));
          } else {
            list = data.map(item => ({
              id: item.id,
              file: item.file || `${item.id}.glb`,
              displayName: item.name || item.id
            }));
          }
        } else {
          throw new Error('index.json format invalide');
        }

        if(list.length === 0) throw new Error('Aucun mod√®le dans index.json');

        if(list.length === 1){
          modelSelectorBox.style.display = 'none';
          await loadModelFromListEntry(list[0]);
        } else {
          modelSelectorBox.style.display = 'block';
          modelSelect.innerHTML = '';
          list.forEach((m)=>{ 
            const o = document.createElement('option');
            o.value = JSON.stringify(m);
            o.textContent = m.displayName || m.id;
            modelSelect.appendChild(o);
          });
          const first = JSON.parse(modelSelect.options[0].value);
          await loadModelFromListEntry(first);
        }

        reloadModelBtn.onclick = async ()=> {
          if(modelSelect.value){
            const entry = JSON.parse(modelSelect.value);
            await loadModelFromListEntry(entry);
          }
        };

      }catch(e){
        console.error(e);
        setStatus('‚ùå Erreur: impossible de charger 3D_display/index.json', '#ff9b9b');
      }
    }

    async function loadModelFromListEntry(entry){
      try{
        setStatus(`‚è≥ Chargement mod√®le ${entry.id} ...`);
        modelGroup.children.slice().forEach(ch=>{ disposeObject(ch); modelGroup.remove(ch); });

        const base = `3D_display/${entry.id}`;
        const glbPath = `${base}/${entry.file}`;
        const boxPath = `${base}/box_template_blank.png`;
        const skinDefaultPath = `${base}/skin.png`;

        const gltf = await loader.loadAsync(glbPath);
        const model = gltf.scene;
        modelGroup.add(model);

        const bbox = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3(); bbox.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z) || 1;
        const desired = 3.2;
        const scl = desired / maxDim;
        model.scale.setScalar(scl);
        const bbox2 = new THREE.Box3().setFromObject(model);
        const center = new THREE.Vector3(); bbox2.getCenter(center);
        model.position.sub(center);

        figurine.length = 0;
        model.traverse((child)=>{
          if(child.isMesh && child.name && child.name.startsWith('fig_')){
            const nm = child.name.trim();
            const overlay = nm.startsWith('fig_2nd_layer_') || detectOverlayFromName(nm);
            figurine.push({ name: nm, mesh: child, overlay });
          }
        });
        buildMeshListUI();

        const texLoader = new THREE.TextureLoader();
        texLoader.load(boxPath, (boxTex)=>{
          boxTex.flipY = false;
          boxTex.encoding = THREE.sRGBEncoding;
          boxTex.magFilter = THREE.NearestFilter;
          boxTex.minFilter = THREE.NearestFilter;
          boxTex.generateMipmaps = false;
          model.traverse((c)=>{ if(c.isMesh && c.name && c.name.startsWith('box_')) c.material = new THREE.MeshStandardMaterial({ map: boxTex }); });
        });

        let loadedSkin = null;
        await new Promise((resolve)=>{ texLoader.load(skinDefaultPath, (t)=>{ loadedSkin = t; resolve(); }, undefined, ()=> resolve()); });
        if(!loadedSkin){ await new Promise((resolve)=>{ texLoader.load('skin.png', (t)=>{ loadedSkin = t; resolve(); }, undefined, ()=> resolve()); }); }
        if(loadedSkin){ applySkinAndLayers(loadedSkin); setStatus(`‚úÖ ${entry.displayName || entry.id} charg√©`, ''); }
        else setStatus(`‚ö†Ô∏è ${entry.displayName || entry.id} charg√© ‚Äî aucun skin par d√©faut trouv√©`, '');

        controls.addEventListener('start', ()=> controls.autoRotate = false);
        controls.addEventListener('end', ()=>{ setTimeout(()=>{ controls.autoRotate = true; }, 700); });

      }catch(err){ console.error(err); setStatus(`‚ùå Erreur chargement ${entry.id}`, '#ff9b9b'); }
    }

    /*********************
     * Skin handling (upload + pseudo Ashcon)
     *********************/
    fileInput.addEventListener('change', (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      fileLabel.textContent = f.name;
      const url = URL.createObjectURL(f);
      const texLoader = new THREE.TextureLoader();
      texLoader.load(url, (tex)=>{ applySkinAndLayers(tex); setStatus('‚úÖ Skin upload appliqu√©'); }, undefined, ()=> setStatus('‚ùå Erreur skin upload', '#ff9b9b'));
    });
    fileLabel.addEventListener('click', ()=> fileInput.click());
    document.querySelector('label[for="fileInput"]')?.addEventListener('click', ()=> fileInput.click());

    // ‚úÖ Pseudo via Ashcon
    fetchSkinBtn.addEventListener('click', async ()=>{
      const name = usernameEl.value.trim();
      if(!name) { setStatus('‚ö†Ô∏è Entre un pseudo', '#ffcc00'); return; }
      setStatus(`üîé Recherche ${name}‚Ä¶`);
      try{
        const res = await fetch('https://api.ashcon.app/mojang/v2/user/' + encodeURIComponent(name));
        if(!res.ok) throw new Error('user not found');
        const data = await res.json();
        const skinUrl = data.textures?.skin?.url;
        if(!skinUrl) throw new Error('skin not found');
        const texLoader = new THREE.TextureLoader();
        texLoader.load(skinUrl, (tex)=>{ applySkinAndLayers(tex); setStatus(`‚úÖ Skin de ${data.username} appliqu√©`); }, undefined, ()=> setStatus('‚ùå Impossible de charger le skin', '#ff9b9b'));
      }catch(e){ console.warn(e); setStatus('‚ùå Pseudo introuvable', '#ff9b9b'); }
    });

    applyDetectedOverlayBtn.addEventListener('click', ()=>{ figurine.forEach(item => item.overlay = detectOverlayFromName(item.name)); buildMeshListUI(); if(currentSkinTexture) applySkinAndLayers(currentSkinTexture); setStatus('üîß Overlay heuristique r√©appliqu√©e'); });
    resetCamBtn.addEventListener('click', ()=> camera.position.set(0,2,6));

    function renderLoop(){ requestAnimationFrame(renderLoop); controls.update(); renderer.render(scene, camera); }
    renderLoop();

    window.addEventListener('resize', ()=>{ const w = Math.max(320, viewer.clientWidth), h = Math.max(240, viewer.clientHeight); camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); });

    loadModelIndex();
  </script>
</body>
</html>
